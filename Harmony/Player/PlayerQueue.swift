//
//  PlayerQueue.swift
//  Harmony
//
//  Created by Claudio Cambra on 26/1/24.
//

import DequeModule
import Foundation
import HarmonyKit
import OSLog
import SwiftData

fileprivate let UserDefaultsRepeatKey = "queue-repeat"

@MainActor
class PlayerQueue: ObservableObject {
    enum RepeatState: Int { case disabled, queue, currentSong }

    static let defaultPageSize = 10
    static let viewLoadTriggerCount = 5
    /// The parent list of songs that the user was viewing when they manually added a song. This is
    /// used to add contextually-relevant previous and upcoming songs.
    @Published var results: LazySequence<[Song]>? {
        // TODO: Listen to changes to this and upd. songs
        didSet {
            shuffledIdentifiers = [] // Shuffle freshly
            pastSongsRepeatStartIndex = nil // Repeat freshly
            repeatIndex = nil
            futureSongs.removeAll()
        }
    }
    /// The currently playing song
    @Published var currentSong: Song?
    /// Songs that have already been played in the current session
    @Published var pastSongs: Deque<Song> = Deque()
    /// Upcoming songs based on the user's actively selected song, the results, and the queue's
    /// shuffle and repeat state. These are automatically generated by the queue from results.
    @Published var futureSongs: Deque<Song> = Deque()
    /// Songs manually chosen by the user to play after the currently playing song. These take
    /// priority over the upcoming songs.
    @Published var playNextSongs: Deque<Song> = Deque()
    /// Shuffle state (on or off). This will affect how upcoming songs are ordered and generated.
    @Published var shuffleEnabled = false {
        didSet { reloadFutureSongs() }
    }
    /// Repeat state (off, repeating queue, or repeating current song). This will affect how upcoming
    /// songs are generated.
    @Published var repeatState = RepeatState(
        rawValue: UserDefaults.standard.integer(forKey: UserDefaultsRepeatKey)
    ) ?? .disabled {
        didSet {
            reloadFutureSongs()
            UserDefaults.standard.set(repeatState.rawValue, forKey: UserDefaultsRepeatKey)
        }
    }
    /// Contains the identifiers for songs that have already been added to upcoming songs. Needed to
    /// not repeat already-added songs during the random sampling of results. This is only relevant
    /// when loading in songs prior to having loaded all relevant results; when repeating the queue,
    /// we simply add new instances of past songs and do not re-shuffle.
    private var shuffledIdentifiers: Set<String> = []
    /// This property tracks at which index, relative to the past songs deque's index 0, we have
    /// loaded all results into the queue's deques. This is used to in two ways; first, if it is not
    /// nil, then we have an easy way of knowing that all of the relevant results have been loaded.
    /// Second, it is used as a nounding number to wrap an iterating index when adding repeating
    /// songs (i.e. if we have 10 songs in total across all deques, and we are loading in 5 songs
    /// starting from index 7, we would load 7->8->9->0->1 as bad index 10 gets
    /// remainderReportingOverflow(dividingBy: ...)
    private var pastSongsRepeatStartIndex: Int?
    /// Tracks the current point at which repetition is taking place. Relevant for un-shuffled queue
    /// repeats.
    private var repeatIndex: Int?
    /// Represents the index in the results of the song the user manually selected to play
    /// (i.e. by tapping or double-clicking it on a list of songs).
    private var addedSongResultsIndex: Int?
    /// Represents the index in results for the last song that was loaded when the user went back
    /// further than the songs thathad been loaded (i.e. added song is 3rd out of 10 results, user
    /// hits back, we load the 2nd song from results).
    private var lastLoadPreviousSongResultsIndex: Int?
    /// Since the queue lazy-loads upcoming songs, this property lets us load in the next page of
    /// songs when we are within a rage of songs before the end of the current upcoming songs deque.
    private var loadRequired: Bool { futureSongs.count <= PlayerQueue.viewLoadTriggerCount }
    /// The last-loaded song in the current deque of upcoming songs
    private var lastLoadedSong: Song? { futureSongs.last ?? currentSong }
    /// Convenience property used to iterate over past, current, play-next, and upcoming songs when
    /// repeating. We need to properly account for the current song when doing this, hence the fake
    /// "count".
    private var currentSongCount: Int { currentSong == nil ? 0 : 1 }
    /// Convenience property that provides the next index, relative to past songs deque index 0, at
    /// which the queue would start repeating.
    private var proposedPastSongsRepeatStartIndex: Int {
        pastSongs.count + currentSongCount + futureSongs.count
    }

    init() {
        let defaults = UserDefaults.standard
        if defaults.value(forKey: UserDefaultsRepeatKey) == nil {
            repeatState = .disabled
        }
    }

    func backward() -> Song? {
        guard let currentSong = currentSong else { return nil }
        var previousSong = pastSongs.popLast()

        if previousSong == nil {
            guard let lastLoadPreviousSongResultsIndex = lastLoadPreviousSongResultsIndex else {
                return nil
            }
            let previousSongResultsIndex = lastLoadPreviousSongResultsIndex - 1
            guard previousSongResultsIndex >= 0 else { return nil }
            guard let previousResultsSong = results?[previousSongResultsIndex] else {
                return nil
            }
            self.lastLoadPreviousSongResultsIndex? -= 1
            previousSong = previousResultsSong
        }

        futureSongs.prepend(currentSong)
        self.currentSong = previousSong

        if pastSongsRepeatStartIndex != nil, pastSongs.count - 1 <= pastSongsRepeatStartIndex! {
            pastSongsRepeatStartIndex = nil
        }

        return previousSong
    }

    func forward() -> Song? {
        guard let currentSong = currentSong else { return nil }

        var nextSong: Song?
        if playNextSongs.isEmpty {
            nextSong = futureSongs.popFirst()
        } else {
            nextSong = playNextSongs.popFirst()
        }
        guard let nextSong = nextSong else { return nil }

        pastSongs.append(currentSong)
        self.currentSong = nextSong

        if loadRequired {
            loadNextPage(nextPageSize: 1)
        }

        return nextSong
    }

    // TODO: This is unnecessary, in the view we know which section each song belongs to, create
    // TODO: more efficient implementation with independent methods
    func moveToSong(instanceId: PersistentIdentifier) async {
        guard let currentSong = currentSong, currentSong.id != instanceId else { return }

        @Sendable func findAndSetSong(_ songs: Deque<Song>, findHandler: @escaping (Int) -> ()) {
            guard let songIndex = songs.firstIndex(where: { song in
                song.id == instanceId
            }) else { return }
            let song = songs[songIndex]

            Task { @MainActor in
                findHandler(songIndex)
                self.currentSong = song
                print(song.title)
            }
        }

        // Explore all queues
        await withDiscardingTaskGroup { group in
            group.addTask {
                await findAndSetSong(self.playNextSongs) { index in
                    Task { @MainActor in
                        self.pastSongs.append(currentSong)
                        self.playNextSongs.remove(at: index)
                    }
                }
            }
            group.addTask {
                await findAndSetSong(self.futureSongs) { index in
                    Task { @MainActor in
                        self.pastSongs.append(currentSong)
                        let preSongIndex = index - 1
                        if preSongIndex >= 0 {
                            for i in 0...preSongIndex {
                                let song = self.futureSongs[i]
                                self.pastSongs.append(song)
                            }
                        }
                        self.futureSongs.removeFirst(index + 1)
                    }
                }
            }
            group.addTask {
                await findAndSetSong(self.pastSongs) { index in
                    Task { @MainActor in
                        let postSongIndex = index + 1
                        if postSongIndex < self.pastSongs.count {
                            for i in (postSongIndex..<self.pastSongs.count).reversed() {
                                let song = self.pastSongs[i]
                                self.futureSongs.prepend(song)
                            }
                        }
                        self.pastSongs.removeLast(self.pastSongs.count - index)
                        self.futureSongs.append(currentSong)
                    }
                }
            }
        }
    }

    func insertNextSong(_ song: Song) {
        song.isPlayNext = true
        playNextSongs.append(song)
    }

    func addCurrentSong(_ song: Song, parentResults: LazySequence<[Song]>) {
        results = parentResults
        addedSongResultsIndex = parentResults.firstIndex(of: song)
        lastLoadPreviousSongResultsIndex = addedSongResultsIndex

        if currentSong?.identifier != song.identifier {
            if let currentSong = currentSong {
                pastSongs.append(currentSong)
            }
            currentSong = song
        }

        loadNextPage()
    }

    func removePastSongs(_ indexSet: IndexSet) {
        pastSongs.remove(atOffsets: indexSet)
        pastSongsRepeatStartIndex? -= indexSet.count
        repeatIndex? -= 1
    }

    func removePlayNextSongs(_ indexSet: IndexSet) {
        playNextSongs.remove(atOffsets: indexSet)
    }

    func removeFutureSongs(_ indexSet: IndexSet) {
        futureSongs.remove(atOffsets: indexSet)
    }

    func clearPastSongs() {
        pastSongs.removeAll()
        pastSongsRepeatStartIndex = nil
    }

    func clearSongsAfterCurrent() {
        playNextSongs.removeAll()
        futureSongs.removeAll()

        shuffledIdentifiers.removeAll()
        repeatIndex = nil
        pastSongsRepeatStartIndex = nil
    }

    func clear() {
        clearPastSongs()
        clearSongsAfterCurrent()

        addedSongResultsIndex = nil
        lastLoadPreviousSongResultsIndex = nil
        results = nil
    }

    func reset() {
        clear()
        currentSong = nil
    }

    func cycleRepeatState() {
        switch repeatState {
        case .disabled:
            repeatState = .queue
        case .queue:
            repeatState = .currentSong
        case .currentSong:
            repeatState = .disabled
        }
    }

    func loadNextPageIfNeeded(song: Song) {
        guard let songIndex = futureSongs.lastIndex(where: { $0.id == song.id }),
              futureSongs.count - 1 - songIndex <= PlayerQueue.viewLoadTriggerCount else { return }
        loadNextPage()
    }

    private func loadNextPage(nextPageSize: Int = PlayerQueue.defaultPageSize) {
        // Handle current song repetition first
        guard repeatState != .currentSong else {
            loadNextPageOfRepeatingCurrentSong(nextPageSize: nextPageSize)
            return
        }

        // We haven't hit the end of the results yet, load more
        if pastSongsRepeatStartIndex == nil {
            loadNextPageFromResults(nextPageSize: nextPageSize)
        }

        // We have hit the end of the results, start loading in repeating songs
        if repeatState == .queue, pastSongsRepeatStartIndex != nil {
            loadNextPageOfRepeatingQueue(nextPageSize: nextPageSize)
        }
    }

    private func reloadFutureSongs() {
        let removedIdentifiers = futureSongs.map { $0.identifier }
        futureSongs.removeAll()
        removedIdentifiers.forEach { identifier in shuffledIdentifiers.remove(identifier) }
        pastSongsRepeatStartIndex = nil
        repeatIndex = nil
        loadNextPage()
    }

    private func loadNextPageOfRepeatingCurrentSong(nextPageSize: Int) {
        guard let currentSong = currentSong else { return }
        for _ in 1...nextPageSize {
            futureSongs.append(currentSong.clone())
        }
    }

    // When we have exhausted all of our results, we just repeat previously played items
    private func loadNextPageOfRepeatingQueue(nextPageSize: Int) {
        guard nextPageSize > 0 else { return }

        if pastSongs.isEmpty, futureSongs.isEmpty {
            guard currentSong != nil else {
                Logger.queue.error("Past songs, future songs, and current song all empty.")
                Logger.queue.error("Cannot load next page of repeating queue.")
                return
            }
            loadNextPageOfRepeatingCurrentSong(nextPageSize: nextPageSize)
            return
        }

        // Default to starting from current song if past is empty and couldn't find in future.
        // This can also happen if the only copy we have of the song in future is the same instance.
        // The minimum possible index we should be getting here is the size of the total queues, as
        // this method only gets run once we have run out of available results and have started
        // repeating; hence the fallback value of totalQueueCount.
        let totalQueueCount = pastSongs.count + currentSongCount + futureSongs.count
        if repeatIndex == nil {
            repeatIndex = totalQueueCount
        } else {
            repeatIndex? += 1
        }
        guard let repeatIndex = repeatIndex else { return }

        var indexBoundary: Int

        guard let pastSongsRepeatStartIndex = pastSongsRepeatStartIndex else {
            Logger.queue.error("pastSongsRepeatStartIndex should be set when repeating!")
            return
        }
        if pastSongsRepeatStartIndex > totalQueueCount - 1 {
            // This is the first repeat, start repeating from beginning of past songs and iterate
            indexBoundary = totalQueueCount
        } else {
            indexBoundary = pastSongsRepeatStartIndex
        }

        let lastIndexToLoad = repeatIndex + nextPageSize - 1

        for unboundedIndex in repeatIndex...lastIndexToLoad {
            let boundedIndex = unboundedIndex.remainderReportingOverflow(
                dividingBy: indexBoundary
            ).partialValue

            var repeatingSong: Song?
            if boundedIndex < pastSongs.count {
                repeatingSong = pastSongs[boundedIndex]
            } else if boundedIndex == pastSongs.count, currentSong != nil {
                repeatingSong = currentSong
            } else if boundedIndex < futureSongs.count {
                repeatingSong = futureSongs[boundedIndex - (pastSongs.count + currentSongCount)]
            }
            guard let newSong = repeatingSong?.clone() else {
                Logger.queue.error("Acquired repeated song clone should not be nil!")
                continue
            }
            futureSongs.append(newSong)
        }
    }

    private func loadNextPageFromResultsShuffled(nextPageSize: Int) {
        guard nextPageSize > 0,
              let addedSongResultsIndex = addedSongResultsIndex,
              let results = results,
              !results.isEmpty
        else { return }

        let afterAddedSongCount = results.count - (addedSongResultsIndex + 1)
        var remainingResults = afterAddedSongCount - shuffledIdentifiers.count
        guard remainingResults > 0 else { return }

        let eligibleRange = addedSongResultsIndex + 1...results.count - 1
        var insertedCount = 0

        while remainingResults > 0, insertedCount < nextPageSize  {
            guard let randomIndex = eligibleRange.randomElement() else { continue }
            let randomSong = results[randomIndex]
            let randomSongIdentifier = randomSong.identifier
            guard !shuffledIdentifiers.contains(randomSongIdentifier) else { continue }
            futureSongs.append(randomSong)
            shuffledIdentifiers.insert(randomSongIdentifier)
            remainingResults -= 1
            insertedCount += 1
        }

        if remainingResults == 0 {
            pastSongsRepeatStartIndex = proposedPastSongsRepeatStartIndex
        } else {
            pastSongsRepeatStartIndex = nil
        }
    }

    private func loadNextPageFromResultsOrdered(nextPageSize: Int) {
        guard nextPageSize > 0,
              let results = results,
              !results.isEmpty,
              let lastLoadedSong = lastLoadedSong
        else {
            Logger.queue.error("Could not load next page of ordered results.")
            return
        }

        // If the shuffle/repeat state has changed we want to load items from results based on the
        // pre-play next items
        var songToBuildQueueFrom = lastLoadedSong
        if songToBuildQueueFrom.isPlayNext, !pastSongs.isEmpty {
            var index = pastSongs.count - 1
            var candidateSong: Song?
            while index >= 0 {
                let song = pastSongs[index]
                if !song.isPlayNext {
                    candidateSong = song
                    break
                }
                index -= 1
            }

            if let candidateSong = candidateSong {
                songToBuildQueueFrom = candidateSong
            }
        }

        guard let lastQueueSongIndex = results.firstIndex(where: {
            $0.identifier == songToBuildQueueFrom.identifier
        }) else {
            Logger.queue.error("Couldn't load next page of ordered results no last queue song idx.")
            return
        }

        let nextResultIndex = results.index(after: lastQueueSongIndex)
        let finalResultIndex = results.count - 1
        guard nextResultIndex <= finalResultIndex else {
            Logger.queue.error("""
                               Received higher next result index \(nextResultIndex)
                               than final index \(finalResultIndex).
                               Could not load next page of ordered results.
                               """)
            return
        }

        let firstResultIndex = min(nextResultIndex, finalResultIndex)
        let lastResultIndex = min(nextResultIndex + nextPageSize - 1, finalResultIndex)

        for i in firstResultIndex...lastResultIndex {
            let song = results[i]
            futureSongs.append(song)
            pastSongsRepeatStartIndex = nil  // We have added new songs, can't be at end index now
        }

        if lastResultIndex == finalResultIndex {
            pastSongsRepeatStartIndex = proposedPastSongsRepeatStartIndex
        }

        Logger.queue.debug("Loaded \((lastResultIndex - firstResultIndex) + 1) ordered results")
    }

    private func loadNextPageFromResults(nextPageSize: Int) {
        if shuffleEnabled {
            loadNextPageFromResultsShuffled(nextPageSize: nextPageSize)
        } else {
            loadNextPageFromResultsOrdered(nextPageSize: nextPageSize)
        }
    }
}
